[Contract]: Contract

[Interface]:
-() [set_admin]
	* Inputs:
	{
		env: Env
		new_admin: Address
	}
	* Instructions:
		$
			{ id: 8, instruction: evaluate, input: (env.storage), assign: METHOD_CALL_EXPRESSION_5, scope: 0 }
			{ id: 9, instruction: evaluate, input: (METHOD_CALL_EXPRESSION_5.instance), assign: METHOD_CALL_EXPRESSION_4, scope: 0 }
			{ id: 10, instruction: evaluate, input: (METHOD_CALL_EXPRESSION_4.get, StorageKey::Admin), assign: INPUT_VALUE_NAME_FOR_LET_1, scope: 0 }
			{ id: 13, instruction: jump, input: (INPUT_VALUE_NAME_FOR_LET_1, 12), scope: 0 }
			{ id: 16, instruction: evaluate, input: (admin.require_auth), scope: 12 }
			{ id: 17, instruction: jump, input: (0), scope: 12 }
			{ id: 26, instruction: evaluate, input: (env.storage), assign: METHOD_CALL_EXPRESSION_23, scope: 0 }
			{ id: 27, instruction: evaluate, input: (METHOD_CALL_EXPRESSION_23.instance), assign: METHOD_CALL_EXPRESSION_22, scope: 0 }
			{ id: 28, instruction: evaluate, input: (METHOD_CALL_EXPRESSION_22.set, StorageKey::Admin, new_admin), scope: 0 }
		$
-() [admin]
	* Inputs:
	{
		env: Env
	}
	* Output: Address
	* Instructions:
		$
			{ id: 7, instruction: evaluate, input: (env.storage), assign: METHOD_CALL_EXPRESSION_4, scope: 0 }
			{ id: 8, instruction: evaluate, input: (METHOD_CALL_EXPRESSION_4.instance), assign: METHOD_CALL_EXPRESSION_3, scope: 0 }
			{ id: 9, instruction: evaluate, input: (METHOD_CALL_EXPRESSION_3.get, StorageKey::Admin), assign: METHOD_CALL_EXPRESSION_0, scope: 0 }
			{ id: 10, instruction: evaluate, input: (METHOD_CALL_EXPRESSION_0.unwrap), assign: Thing_to_return, scope: 0 }
			{ id: 0, instruction: return, input: (Thing_to_return), scope: 0 }
		$
-() [set_minter]
	* Inputs:
	{
		env: Env
		contract: Address
		minter: Address
		config: MinterConfig
	}
	* Instructions:
		$
			{ id: 3, instruction: evaluate, input: (env.clone), assign: CALL_EXPRESSION_ARG_1, scope: 0 }
			{ id: 6, instruction: evaluate, input: (admin, CALL_EXPRESSION_ARG_1), assign: METHOD_CALL_EXPRESSION_0, scope: 0 }
			{ id: 7, instruction: evaluate, input: (METHOD_CALL_EXPRESSION_0.require_auth), scope: 0 }
			{ id: 20, instruction: evaluate, input: (env.storage), assign: METHOD_CALL_EXPRESSION_17, scope: 0 }
			{ id: 21, instruction: evaluate, input: (METHOD_CALL_EXPRESSION_17.persistent), assign: METHOD_CALL_EXPRESSION_16, scope: 0 }
			{ id: 13, instruction: evaluate, input: (StorageKey::Minter, contract, minter), assign: METHOD_CALL_ARG_1_8, scope: 0 }
			{ id: 22, instruction: evaluate, input: (METHOD_CALL_EXPRESSION_16.set, METHOD_CALL_ARG_1_8, config), scope: 0 }
		$
-() [minter]
	* Inputs:
	{
		env: Env
		contract: Address
		minter: Address
	}
	* Output: Result<(MinterConfig, Integer, MinterStats), Error>
	* Instructions:
		$
			{ id: 17, instruction: evaluate, input: (env.storage), assign: METHOD_CALL_EXPRESSION_14, scope: 0 }
			{ id: 18, instruction: evaluate, input: (METHOD_CALL_EXPRESSION_14.persistent), assign: METHOD_CALL_EXPRESSION_13, scope: 0 }
			{ id: 6, instruction: evaluate, input: (contract.clone), assign: CALL_EXPRESSION_ARG_1, scope: 0 }
			{ id: 9, instruction: evaluate, input: (minter.clone), assign: CALL_EXPRESSION_ARG_2, scope: 0 }
			{ id: 12, instruction: evaluate, input: (StorageKey::Minter, CALL_EXPRESSION_ARG_1, CALL_EXPRESSION_ARG_2), assign: METHOD_CALL_ARG_1_3, scope: 0 }
			{ id: 19, instruction: evaluate, input: (METHOD_CALL_EXPRESSION_13.get, METHOD_CALL_ARG_1_3), assign: METHOD_CALL_EXPRESSION_2, scope: 0 }
			{ id: 20, instruction: evaluate, input: (METHOD_CALL_EXPRESSION_2.ok_or, Error::NotAuthorizedMinter), assign: config, scope: 0 }
			{ id: 26, instruction: evaluate, input: (env.ledger), assign: METHOD_CALL_EXPRESSION_23, scope: 0 }
			{ id: 27, instruction: evaluate, input: (METHOD_CALL_EXPRESSION_23.sequence), assign: BINARY_EXPRESSION_LEFT_21, scope: 0 }
			{ id: 32, instruction: divide, input: (BINARY_EXPRESSION_LEFT_21, config.epoch_length), assign: epoch, scope: 0 }
			{ id: 53, instruction: evaluate, input: (env.storage), assign: METHOD_CALL_EXPRESSION_50, scope: 0 }
			{ id: 54, instruction: evaluate, input: (METHOD_CALL_EXPRESSION_50.temporary), assign: METHOD_CALL_EXPRESSION_49, scope: 0 }
			{ id: 37, instruction: evaluate, input: (contract.clone), assign: CALL_EXPRESSION_ARG_1, scope: 0 }
			{ id: 40, instruction: evaluate, input: (minter.clone), assign: CALL_EXPRESSION_ARG_2, scope: 0 }
			{ id: 48, instruction: evaluate, input: (StorageKey::MinterStats, CALL_EXPRESSION_ARG_1, CALL_EXPRESSION_ARG_2, config.epoch_length, epoch), assign: METHOD_CALL_ARG_1_34, scope: 0 }
			{ id: 55, instruction: evaluate, input: (METHOD_CALL_EXPRESSION_49.get, METHOD_CALL_ARG_1_34), assign: METHOD_CALL_EXPRESSION_33, scope: 0 }
			{ id: 56, instruction: evaluate, input: (METHOD_CALL_EXPRESSION_33.unwrap_or_default), assign: stats, scope: 0 }
			{ id: 60, instruction: instantiate_object, input: (Tuple, config, epoch, stats), assign: CALL_EXPRESSION_ARG_1, scope: 0 }
			{ id: 64, instruction: evaluate, input: (Ok, CALL_EXPRESSION_ARG_1), assign: Thing_to_return, scope: 0 }
			{ id: 0, instruction: return, input: (Thing_to_return), scope: 0 }
		$
-() [mint]
	* Inputs:
	{
		env: Env
		contract: Address
		minter: Address
		to: Address
		amount: BigInteger
	}
	* Output: Result<(), Error>
	* Instructions:
		$
			{ id: 7, instruction: instantiate_object, input: (Tuple, contract, to, amount), assign: METHOD_CALL_EXPRESSION_3, scope: 0 }
			{ id: 9, instruction: evaluate, input: (METHOD_CALL_EXPRESSION_3.into_val, env), assign: METHOD_CALL_ARG_1_0, scope: 0 }
			{ id: 12, instruction: evaluate, input: (minter.require_auth_for_args, METHOD_CALL_ARG_1_0), scope: 0 }
			{ id: 18, instruction: evaluate, input: (less_than, amount, 0), assign: CONDITIONAL_JUMP_ASSIGNMENT_13, scope: 0 }
			{ id: 20, instruction: jump, input: (CONDITIONAL_JUMP_ASSIGNMENT_13, 19), scope: 0 }
			{ id: 25, instruction: evaluate, input: (Err, Error::NegativeAmount), assign: RETURN_VALUE_LABEL_21, scope: 19 }
			{ id: 26, instruction: return, input: (RETURN_VALUE_LABEL_21), assign: Thing_to_return, scope: 19 }
			{ id: 30, instruction: evaluate, input: (env.clone), assign: CALL_EXPRESSION_ARG_1, scope: 0 }
			{ id: 33, instruction: evaluate, input: (admin, CALL_EXPRESSION_ARG_1), assign: admin, scope: 0 }
			{ id: 39, instruction: evaluate, input: (not_equal_to, admin, minter), assign: CONDITIONAL_JUMP_ASSIGNMENT_34, scope: 0 }
			{ id: 41, instruction: jump, input: (CONDITIONAL_JUMP_ASSIGNMENT_34, 40), scope: 0 }
			{ id: 56, instruction: evaluate, input: (env.storage), assign: METHOD_CALL_EXPRESSION_53, scope: 40 }
			{ id: 57, instruction: evaluate, input: (METHOD_CALL_EXPRESSION_53.persistent), assign: METHOD_CALL_EXPRESSION_52, scope: 40 }
			{ id: 45, instruction: evaluate, input: (contract.clone), assign: CALL_EXPRESSION_ARG_1, scope: 40 }
			{ id: 48, instruction: evaluate, input: (minter.clone), assign: CALL_EXPRESSION_ARG_2, scope: 40 }
			{ id: 51, instruction: evaluate, input: (StorageKey::Minter, CALL_EXPRESSION_ARG_1, CALL_EXPRESSION_ARG_2), assign: METHOD_CALL_ARG_1_42, scope: 40 }
			{ id: 58, instruction: evaluate, input: (METHOD_CALL_EXPRESSION_52.get, METHOD_CALL_ARG_1_42), assign: Some(config ), scope: 40 }
			{ id: 63, instruction: evaluate, input: (Err, Error::NotAuthorizedMinter), assign: RETURN_VALUE_LABEL_59, scope: 40 }
			{ id: 64, instruction: return, input: (RETURN_VALUE_LABEL_59), assign: Thing_to_return, scope: 40 }
			{ id: 130, instruction: evaluate, input: (Err, Error::DailyLimitInsufficient), assign: RETURN_VALUE_LABEL_126, scope: 124 }
			{ id: 131, instruction: return, input: (RETURN_VALUE_LABEL_126), assign: Thing_to_return, scope: 124 }
			{ id: 169, instruction: evaluate, input: (MintClient::new, env, contract), assign: client, scope: 0 }
			{ id: 176, instruction: evaluate, input: (client.mint, to, amount), scope: 0 }
			{ id: 177, instruction: instantiate_object, input: (Tuple), assign: CALL_EXPRESSION_ARG_1, scope: 0 }
			{ id: 181, instruction: evaluate, input: (Ok, CALL_EXPRESSION_ARG_1), assign: Thing_to_return, scope: 0 }
			{ id: 0, instruction: return, input: (Thing_to_return), scope: 0 }
		$
:[Interface]


[User Defined Types]:
* (Error_ENUM)
{
	NotAuthorizedMinter = 1
	DailyLimitInsufficient = 2
	NegativeAmount = 3
}

* (StorageKey_ENUM)
{
	Admin: ()
	Minter: (Address, Address)
	MinterStats: (Address, Address, Integer, Integer)
}
* (MinterConfig_STRUCT)
{
	limit: BigInteger
	epoch_length: Integer
}
* (MinterStats_STRUCT)
{
	consumed_limit: BigInteger
}

:[User Defined Types]

